# [4주차] 분산컴퓨팅

# Saga 패턴 (Saga Pattern)

분산 시스템, 특히 마이크로서비스 아키텍처 환경에서는 하나의 비즈니스 로직이 여러 서비스에 걸쳐 실행되는 경우가 많다. 이때 전통적인 분산 트랜잭션 기법인 2단계 커밋 프로토콜은 TC 의존, Blocking 문제, 확장성 저하 등의 한계를 가진다.

saga 패턴 사용 상황

-트랜잭션이 여러 마이크로서비스에 걸쳐 있음

-각 서비스가 자신의 데이터베이스를 소유하고 있음

-일시적인 데이터 불일치를 비즈니스적으로 허용 가능

-시스템 전체가 멈추는 것보다, 일부 실패 후 복구가 더 중요

→Saga는 강한 일관성보다 시스템 가용성과 확장성을 우선하는 환경에서 사용된다.

**Oracle Database/IBM Db2/Microsoft SQL Server**

**MySQL / PostgreSQL** /금융시스템

---

## 개념

Saga는 하나의 글로벌 트랜잭션을 여러 개의 **로컬 트랜잭션(Local Transaction)** 으로 분해하여 처리한다.

-각 로컬 트랜잭션은 **자신의 서비스 내부 데이터베이스만** 수정

-모든 로컬 트랜잭션이 순차적으로 성공하면 Saga는 성공

-중간 단계에서 실패가 발생하면, 이미 완료된 단계들에 대해 보상 트랜잭션을 실행하여 이전 상태로 되돌림

즉, Saga는 “모두 성공하거나 모두 취소”를 즉시 보장하지 않고, 실패 시 보상 작업을 통해 결과적으로 일관된 상태를 만드는 방식

## 동작 구조

1. 트랜잭션을 여러 개의 로컬 트랜잭션으로 분해
2. 각 로컬 트랜잭션을 순서대로 실행
3. 모든 단계가 성공하면 종료
4. 특정 단계에서 실패 시:
    
    -이전에 성공한 로컬 트랜잭션들에 대해 역순으로 보상 트랜잭션(이미 커밋된 작업을 취소**)** 실행
    

![image.png](image.png)

Saga 트랜잭션은 2PC처럼 즉시 원자성을 보장하지 않고, 각 단계가 커밋된 이후 실패 시 보상 트랜잭션을 통해 결과적 일관성을 달성하는 방식이다. Orchestration과 Choreography는 “누가 흐름을 통제하느냐”의 차이다.

### Choreography 기반 Saga

각 서비스가 이벤트를 발행하고, 다음 동작을 수행할 서비스가 해당 이벤트를 구독하여 처리하는 방식이다.

중앙 제어자 없음

서비스 간 직접 이벤트 기반 협력

**장점**

높은 느슨한 결합(Loose Coupling)

단일 장애 지점(Single Point of Failure) 없음

확장성과 유연성 우수

### 단점

전체 트랜잭션 흐름 파악이 어려움

서비스 수가 많아질수록 로직이 분산되어 복잡해짐

디버깅 및 추적이 어려움

---

### Orchestration 기반 Saga

중앙의 Saga 오케스트레이터가 존재하며, 각 서비스에게 명령을 내려 트랜잭션을 순차적으로 제어하는 방식이다.

-중앙 오케스트레이터가 흐름 관리

-서비스는 명령을 수행하고 결과만 반환

### 장점

트랜잭션 흐름이 명확

로직 관리 및 추적이 쉬움

### 단점

오케스트레이터가 장애 시 문제 발생 가능

중앙 제어로 인한 결합도 증가

### 한계

중간 상태에서 데이터 불일치가 발생할 수 있음

모든 로컬 트랜잭션에 대해 **보상 트랜잭션 설계 필요**

보상 트랜잭션이 항상 완벽하게 이전 상태를 복원하지 못할 수도 있음

ex) 외부 결제 API 호출/사용자에게 이미 발송된 알림/물리적으로 출고된 상품

## 2PC와 Saga

2PC: 잘못된 결과를 절대 허용하지 않음(Safety 최우선)

Saga: 일시적인 불일치를 허용하되, 시스템이 멈추지 않고 결국 정상 상태에 도달하는 것을 중시(Liveness 중시)