#1장

## 두 장군 문제
>**분산 컴퓨팅에서 발생하는 대표적인 문제**

![](https://velog.velcdn.com/images/likell1/post/8957713e-8494-4966-ae6f-7bb8704e111f/image.png)

---
#### 조건

- 두 명의 장군 **A**와 **B**가 있음
- 각각의 군대는 서로 **떨어진 위치**에 있음 (서로 완전히 떨어짐)
- 적의 성을 **동시에 공격해야만 승리**
- 통신 수단은 **메신저(messenger)** 뿐
- 전령은 **적에게 잡힐 수 있음 (메시지 유실 가능)**

---
#### 과정

- **A → B**
    
    > “내일 새벽에 공격하자”
    
    ❓ 문제:
    
    - **B가 메시지를 받았는지 A는 모름**
    

- **B → A (확인 응답)**
    
    > “알겠다. 공격하자”
    > 
    
    ❓ 문제:
    
    - **이 응답이 A에게 도착했는지 B는 모름**

- **A → B (확인에 대한 확인)**
    
    > “네가 받은 거 확인했다”
    > 
    
    ❓ 문제:
    
    - 또 이 메시지가 도착했는지 불확실…


> 👉🏻 **즉, 서로가 서로를 신뢰할 수 없음**

---
#### 결론

- 즉, **비동기 통신 환경(메세지가 유실될 수 있는)**에서 **상호 확신**은 **불가능**
- 네트워크 환경에서 “상대가 알았다는 것을 나도 알기까지” **무한한 메시지가 필요**함
    - *A: 너 확인했어??*
    - *B: 응 확인했는데, 넌 내가 확인한걸 확인했어?? (무한 반복)*

> **🔑 불완전한 네트워크에서 완벽한 합의는 불가능하다.**

---
### 두 장군 문제를 분산 시스템에 대응하면

| **두 장군 문제** | **분산 시스템** |
| --- | --- |
| 전령이 잡힘 | 네트워크 패킷 유실 |
| 장군 | 노드 / 서버 |
| 공격 | 커밋(commit), 실행 |
| 동시 공격 | 트랜잭션 합의 |

---

## 분산 컴퓨팅 (Distributed Computing)

> 작업을 수행하는 전자 · 기계 장치들이 네트워크에 연결되어 서로 메세지를 주고 받으면서 **협의 과정을 거쳐 어떤 목적 달성을 위해 함께 작업을 수행하는 것**
> 

### 분산 컴퓨팅의 주체

- 컴퓨팅 장치
- 네트워크
- 네트워크 패킷


> **🔎 분산 컴퓨팅의 주요 문제는 비동기적인 통신 환경 때문에 발생한다.**


- **비동기적인 통신:** 메세지의 전달 여부나 정해진 시각 안의 도달을 보장할 수 없는 네트워크 환경

---
# 2장

# 안정성과 라이브니스

> 분산 컴퓨팅에서 반드시 보장되어야 하는 원칙
**위반할 시 치명적인 문제가 발생할 수 있다.**
> 

---

### 안정성(Safety)

> **잘못된 결과가 일어나서는 안 되는 원칙.** 즉, 어느 시점에서도 이런 일이 일어나서는 안된다는 조건이다.
> 

e.g.) 주문이 2번 결제되서는 안된다.

---

### 라이브니스(Liveness)

> **원하는 결과가 반드시 어느 시점에서는 실현되어야 하는 원칙**
> 

e.g.) 메시지가 언젠가는 도착한다.

---

안정성과 라이브니스는 **트레이드오프 관계**가 있어서
안정성에만 초점을 맞추다보면, 라이브니스를 충족하지 못하게 될 수 있고,
라이브니스에만 초점을 맞추다보면, 안정성을 놓치게 될 수 있다.

> **즉, 라이브니스와 안정성을 모두 고려하려다가 교착상태(Deadlock)에 빠질 수 있다.**
> 

---

### 트랜잭션(Transaction)

> **분산 컴퓨팅 참여 프로세스들 간의 거래 행위**

e.g.) A가 B에게 10,000원을 송금하는 행위

#### 트랜잭션의 특징

트랜잭션이 **원자성을 가지면 최소한의 안정성이 보장**된다.

분산 시스템 환경에서는 **트랜잭션을 중계하는 중재자(TC)가 필요하다.**

---

## 계좌이체로 보는 안정성과 라이브니스

![](https://velog.velcdn.com/images/likell1/post/76f21bc3-3ece-4c54-9dd8-be35142c81f9/image.png)


<aside>
✂️ Alice와 Bob 두 명이 있고,

Alice → Bob 에게 1,000원을 송금하는 상황이다.

Alice는 K 은행을 이용하고, Bob은 S 은행을 이용하는 중이다.

</aside>

> **📌 계좌이체라는 트랜잭션에서, 안전성과 라이브니스를 보장하는 방법을 살펴보자.**
> 

---

## 원자적 커밋 프로토콜

> 
> 

![](https://velog.velcdn.com/images/likell1/post/47f8e19f-a733-4968-972e-41c391a8b84f/image.jpeg)

- 먼저 Alice가 Bob에게 송금하기 위해, TC에게 명령을 요청한다.
- 그 후 TC는 각 은행에게, 입출금 준비가 되었는지 여부를 묻는 메시지를 전송한다.

---

### **이행 커밋**

![](https://velog.velcdn.com/images/likell1/post/7f1fc0e3-4d91-4959-8ebe-b376e87c4851/image.png)


- 각 은행이 모두 “**준비완료 ✅”**가 되었다고, TC에게 회신하면,
- TC는 각 은행에게 입/출금 할 것을 명령하는 **커밋 메시지**를 보낸다.
- 그 후에, TC는 Alice에게 **송금이 완료되었다는 메시지를 보낸다.**

---

### **이행 취소**

![](https://velog.velcdn.com/images/likell1/post/e320763d-7dcd-4f57-b594-7570c74f6d55/image.png)


- 만약, 어느 한 은행이 “**준비 완료 ❌ 메시지**”를 보내거나, 또는 **메시지가 도착하지 않는다면**,
- TC는 명령을 취소하고, Alice 에게 송**금이 실패했다는 메시지를 보낸다.**

---

이것이 원자적 커밋 프로토콜의 과정이다.

하지만 모든 상황에서 원자적 커밋 프로토콜이 정상적으로 작동할까??

> **⚠️ 정답은 No! ❌**
> 

---

> **만약에 TC가 중단되는 상황을 가정해보자.**
> 

![](https://velog.velcdn.com/images/likell1/post/4201b210-56d0-48e0-bfac-cec159a42c37/image.png)


- 모든 은행이 준비완료 되어서 TC가 입/출금 명령하는 커밋 메시지를 전송한다.
- 이때, 보낸 즉시 TC가 중단되어 버리면 어떻게 될까?

![](https://velog.velcdn.com/images/likell1/post/da940526-15f1-4302-9b65-7bd592d88074/image.png)


- TC가 복구되었을 때, 각 은행에게 커밋 메시지를 보냈는지 기억을 하지 못하고
- Alice 에게 송금 완료 메시지도 보낼 수 없다. ❌

![](https://velog.velcdn.com/images/likell1/post/b02e3649-4fda-4218-90d1-8fef4ab2112b/image.png)

- 따라서, TC는 커밋 메시지를 보내기 직전에 디스크에 **“커밋 메시지를 보낼 것”이라는 로그를 저장해둔다.**
- 이렇게 되면 TC가 중단되어도, 디스크의 로그를 보고 Alice 에게 송금 완료여부를 알려줄 수 있다.

---

> **만약에 은행이 중단되는 경우라면 어떨까?**
> 

![](https://velog.velcdn.com/images/likell1/post/6a66615a-2a88-42ac-ae53-c58d7ab48afc/image.png)


- 은행이 준비완료 메시지를 보낸 즉시, 서버가 중단되는 경우를 생각해보자.
- 이 경우에는 심각한 문제가 생길 수 있는데..

![](https://velog.velcdn.com/images/likell1/post/d0270980-48a6-4cf1-857a-2ebebbd7f480/image.png)


- TC는 준비 완료 메시지를 받고, 각 은행에게 입/출금 커밋 메시지를 보낸다.
- K 은행은 합의에 의해 1,000원 마이너스 하지만, S 은행은 서버가 중단된 상태라, 커밋 메시지를 받지 못한다. ❌
- 이렇게 되면, Alice만 1,000원을 잃게 되고, 안정성이 깨지는 문제가 발생한다.

![](https://velog.velcdn.com/images/likell1/post/422ae28e-6f55-4ea7-8e78-1624d85990c5/image.png)


- 따라서 각 은행도, 준비 완료 메시지를 보내기 직전, 디스크에 로그를 저장해서,

![](https://velog.velcdn.com/images/likell1/post/0ad9f766-cc2c-446d-af83-61250af07d01/image.png)


- 서버 복구 후, 준비완료 되었다고 TC에게 전송했는데, 자신에게 커밋 메시지가 도착하지 않은 것을 확인 후에
- TC에게 준비완료 메시지를 재전송한다.
- TC는 준비완료 메시지를 확인 → 커밋 메시지 재전송 → 안정성 보장

> 이렇게 프로토콜에 참여하는 주체가 모두 동의하는 상황에만 작동하도록 보장하여 안정성을 보장하였다.
그렇다면, 이제 모든 것이 해결되었을까??
> 

**정답은 No ❌**

⚠️ **아직 해결해야할 문제가 남았다.**

---

> **만약, K 은행이 “준비 완료” 메시지를 보내려는 찰나에 중단되어 버렸다고 가정해보자.**
> 

![](https://velog.velcdn.com/images/likell1/post/37d519d8-976d-45bb-887c-2bf7897c7607/image.png)


- TC는 **“준비완료 메시지”를 받지 못함 ❌** → **무한정 기다림 ⚠️** → **라이브니스 불충족**

---

> **만약, TC가 “커밋 메시지”를 보내려는 찰나에 중단되어 버렸다고 가정하면?**
> 

![](https://velog.velcdn.com/images/likell1/post/65bea933-8322-4d19-885a-3fdeec24422c/image.png)


- K, S 은행은 **“커밋 메시지”를 받지 못함 ❌** → **무한정 기다림 ⚠️** → **라이브니스 불충족**

> 위 2가지 경우 모두 안정성은 충족하더라도, 라이브니스는 충족하지 못한다.
> 

---

그렇다면 어떻게 해결할 수 있을까?

TC가 프로토콜을 처음부터 재시작하는 방법도 있겠지만, 이 경우 시간과 비용이 더 소모되므로, 최적의 솔루션은 아니다.

> **👉🏻 그렇다면? → 은행끼리 서로 소통하는 상황은 어떨까?**
> 

다음은 **은행🏦 끼리 서로 소통하는 상황을 그려 해결**하는 아키텍쳐이다.

우선 쉽게 설명하기 위해 **S가 커밋 메시지를 받지 못했고**, **S 은행 → K 은행에 문의하는 상황만 가정하면,**

**4가지 경우**가 존재한다.

![](https://velog.velcdn.com/images/likell1/post/4f23c190-c486-4483-9569-0eae8595a8cc/image.png)


1. **K가 무응답인 경우**
> K가 무응답인 경우, K의 서버가 중단된 경우이므로, TC의 명령을 기다린다.


2. 프로토콜 주체는 정상 작동 중이지만, **네트워크 오류**가 발생한 경우
>**통신 환경에서는 네트워크 오류가 발생할 수 있다.**
만약 K에게는 커밋 메시지가 정상 전송되고, 네트워크 오류로 S만 받지 못했다면, S는 재전송 없이 커밋 명령을 수행한다.
>
    

3. K가 **이미 “준비 ❌ 메시지”를 TC에게 보낸 경우**
>이 경우, 어차피 합의가 되지 않아 프로토콜이 작동하지 않는 경우이므로, S도 취소한다.
    
4. K가 **“준비 완료 ✅ 메시지”를 TC에게 보낸 경우**
>이 경우, TC에게 문제가 생긴 경우이므로, TC가 재전송할 때까지 기다린다.


> 👉🏻 **이렇게 문제를 해결하는 것이 2단계 커밋 프로토콜의 아이디어이다.**
> 

---

## 2단계 커밋 프로토콜

> **📌 원자적 커밋 프로토콜에 선제적 메시지 기록 및 재시작의 조건을 더해서 안정성과 라이브니스 모두를 보장하는 프로토콜이 “2단계 커밋 프로토콜”, 즉 2PC 프로토콜이라고 정의한다.**
> 

---
### 2PC 커밋 프로토콜의 대표 예시

#### 1. 준비완료 메시지를 보내기 전에 은행 서버가 중단되고 로그도 저장하지 못한 경우

![](https://velog.velcdn.com/images/likell1/post/ab628fc7-0e32-4af7-9f39-854c2ebe5244/image.png)


> **이 경우, TC는 Timeout을 정해놓고, 일정시간 메시지가 도착하지 않으면, 취소 메시지를 보낸다.**
> 

---

#### 2. 준비완료 메시지를 보낸 후에 은행 서버가 중단된 경우

![](https://velog.velcdn.com/images/likell1/post/4a8e2a2e-5568-402b-80fb-3718e28fe224/image.png)


> **이 경우, S 은행은 복구 후에 로그를 확인하고, K 은행에 문의하여 K의 답변에 따라 동작을 수행한다.**
> 

---

#### 3. S 은행이 로그는 저장했지만, 준비완료 메시지를 보내지도 못하고, 서버가 중단딘 경우

![](https://velog.velcdn.com/images/likell1/post/e09631cb-7be2-4985-823f-a15a9f7d8e61/image.png)


> **이 경우, TC는 Timeout을 정해놓고, 일정시간 메시지가 도착하지 않으면, 취소 메시지를 보낸다.
만약, S 은행이 복구 후에, 메시지를 재전송하여도, 이미 취소 메시지를 보냈기 때문에,
TC는 다시 취소 메시지를 전송한다.**
> 

---

#### 4. TC가 커밋 메시지를 보낸 즉시, 중단되고, S가 못 받은 경우

![](https://velog.velcdn.com/images/likell1/post/34c58233-5593-4f14-b688-3caaa76a7d06/image.png)


> **이 경우, S는 K에게 문의한 후, K의 답변에 따라 동작을 수행한다.**
> 

> **🔥 2PC 프로토콜은 이러한 방식으로, 
어떤 경우에도 안정성과 라이브니스를 모두 보장하는 프로토콜을 동작시킬 수 있다.**
>